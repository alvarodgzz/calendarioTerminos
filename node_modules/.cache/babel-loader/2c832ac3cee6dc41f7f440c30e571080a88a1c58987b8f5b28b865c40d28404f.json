{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Collection = void 0;\nconst bson_1 = require(\"./bson\");\nconst ordered_1 = require(\"./bulk/ordered\");\nconst unordered_1 = require(\"./bulk/unordered\");\nconst change_stream_1 = require(\"./change_stream\");\nconst aggregation_cursor_1 = require(\"./cursor/aggregation_cursor\");\nconst find_cursor_1 = require(\"./cursor/find_cursor\");\nconst list_indexes_cursor_1 = require(\"./cursor/list_indexes_cursor\");\nconst error_1 = require(\"./error\");\nconst bulk_write_1 = require(\"./operations/bulk_write\");\nconst count_1 = require(\"./operations/count\");\nconst count_documents_1 = require(\"./operations/count_documents\");\nconst delete_1 = require(\"./operations/delete\");\nconst distinct_1 = require(\"./operations/distinct\");\nconst drop_1 = require(\"./operations/drop\");\nconst estimated_document_count_1 = require(\"./operations/estimated_document_count\");\nconst execute_operation_1 = require(\"./operations/execute_operation\");\nconst find_and_modify_1 = require(\"./operations/find_and_modify\");\nconst indexes_1 = require(\"./operations/indexes\");\nconst insert_1 = require(\"./operations/insert\");\nconst is_capped_1 = require(\"./operations/is_capped\");\nconst options_operation_1 = require(\"./operations/options_operation\");\nconst rename_1 = require(\"./operations/rename\");\nconst stats_1 = require(\"./operations/stats\");\nconst update_1 = require(\"./operations/update\");\nconst read_concern_1 = require(\"./read_concern\");\nconst read_preference_1 = require(\"./read_preference\");\nconst utils_1 = require(\"./utils\");\nconst write_concern_1 = require(\"./write_concern\");\n/**\n * The **Collection** class is an internal class that embodies a MongoDB collection\n * allowing for insert/find/update/delete and other command operation on that MongoDB collection.\n *\n * **COLLECTION Cannot directly be instantiated**\n * @public\n *\n * @example\n * ```ts\n * import { MongoClient } from 'mongodb';\n *\n * interface Pet {\n *   name: string;\n *   kind: 'dog' | 'cat' | 'fish';\n * }\n *\n * const client = new MongoClient('mongodb://localhost:27017');\n * const pets = client.db().collection<Pet>('pets');\n *\n * const petCursor = pets.find();\n *\n * for await (const pet of petCursor) {\n *   console.log(`${pet.name} is a ${pet.kind}!`);\n * }\n * ```\n */\nclass Collection {\n  /**\n   * Create a new Collection instance\n   * @internal\n   */\n  constructor(db, name, options) {\n    (0, utils_1.checkCollectionName)(name);\n    // Internal state\n    this.s = {\n      db,\n      options,\n      namespace: new utils_1.MongoDBNamespace(db.databaseName, name),\n      pkFactory: db.options?.pkFactory ?? utils_1.DEFAULT_PK_FACTORY,\n      readPreference: read_preference_1.ReadPreference.fromOptions(options),\n      bsonOptions: (0, bson_1.resolveBSONOptions)(options, db),\n      readConcern: read_concern_1.ReadConcern.fromOptions(options),\n      writeConcern: write_concern_1.WriteConcern.fromOptions(options)\n    };\n  }\n  /**\n   * The name of the database this collection belongs to\n   */\n  get dbName() {\n    return this.s.namespace.db;\n  }\n  /**\n   * The name of this collection\n   */\n  get collectionName() {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.s.namespace.collection;\n  }\n  /**\n   * The namespace of this collection, in the format `${this.dbName}.${this.collectionName}`\n   */\n  get namespace() {\n    return this.s.namespace.toString();\n  }\n  /**\n   * The current readConcern of the collection. If not explicitly defined for\n   * this collection, will be inherited from the parent DB\n   */\n  get readConcern() {\n    if (this.s.readConcern == null) {\n      return this.s.db.readConcern;\n    }\n    return this.s.readConcern;\n  }\n  /**\n   * The current readPreference of the collection. If not explicitly defined for\n   * this collection, will be inherited from the parent DB\n   */\n  get readPreference() {\n    if (this.s.readPreference == null) {\n      return this.s.db.readPreference;\n    }\n    return this.s.readPreference;\n  }\n  get bsonOptions() {\n    return this.s.bsonOptions;\n  }\n  /**\n   * The current writeConcern of the collection. If not explicitly defined for\n   * this collection, will be inherited from the parent DB\n   */\n  get writeConcern() {\n    if (this.s.writeConcern == null) {\n      return this.s.db.writeConcern;\n    }\n    return this.s.writeConcern;\n  }\n  /** The current index hint for the collection */\n  get hint() {\n    return this.s.collectionHint;\n  }\n  set hint(v) {\n    this.s.collectionHint = (0, utils_1.normalizeHintField)(v);\n  }\n  /**\n   * Inserts a single document into MongoDB. If documents passed in do not contain the **_id** field,\n   * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n   * can be overridden by setting the **forceServerObjectId** flag.\n   *\n   * @param doc - The document to insert\n   * @param options - Optional settings for the command\n   */\n  async insertOne(doc, options) {\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new insert_1.InsertOneOperation(this, doc, (0, utils_1.resolveOptions)(this, options)));\n  }\n  /**\n   * Inserts an array of documents into MongoDB. If documents passed in do not contain the **_id** field,\n   * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n   * can be overridden by setting the **forceServerObjectId** flag.\n   *\n   * @param docs - The documents to insert\n   * @param options - Optional settings for the command\n   */\n  async insertMany(docs, options) {\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new insert_1.InsertManyOperation(this, docs, (0, utils_1.resolveOptions)(this, options ?? {\n      ordered: true\n    })));\n  }\n  /**\n   * Perform a bulkWrite operation without a fluent API\n   *\n   * Legal operation types are\n   * - `insertOne`\n   * - `replaceOne`\n   * - `updateOne`\n   * - `updateMany`\n   * - `deleteOne`\n   * - `deleteMany`\n   *\n   * If documents passed in do not contain the **_id** field,\n   * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n   * can be overridden by setting the **forceServerObjectId** flag.\n   *\n   * @param operations - Bulk operations to perform\n   * @param options - Optional settings for the command\n   * @throws MongoDriverError if operations is not an array\n   */\n  async bulkWrite(operations, options) {\n    if (!Array.isArray(operations)) {\n      throw new error_1.MongoInvalidArgumentError('Argument \"operations\" must be an array of documents');\n    }\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new bulk_write_1.BulkWriteOperation(this, operations, (0, utils_1.resolveOptions)(this, options ?? {\n      ordered: true\n    })));\n  }\n  /**\n   * Update a single document in a collection\n   *\n   * @param filter - The filter used to select the document to update\n   * @param update - The update operations to be applied to the document\n   * @param options - Optional settings for the command\n   */\n  async updateOne(filter, update, options) {\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new update_1.UpdateOneOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options)));\n  }\n  /**\n   * Replace a document in a collection with another document\n   *\n   * @param filter - The filter used to select the document to replace\n   * @param replacement - The Document that replaces the matching document\n   * @param options - Optional settings for the command\n   */\n  async replaceOne(filter, replacement, options) {\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new update_1.ReplaceOneOperation(this, filter, replacement, (0, utils_1.resolveOptions)(this, options)));\n  }\n  /**\n   * Update multiple documents in a collection\n   *\n   * @param filter - The filter used to select the documents to update\n   * @param update - The update operations to be applied to the documents\n   * @param options - Optional settings for the command\n   */\n  async updateMany(filter, update, options) {\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new update_1.UpdateManyOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options)));\n  }\n  /**\n   * Delete a document from a collection\n   *\n   * @param filter - The filter used to select the document to remove\n   * @param options - Optional settings for the command\n   */\n  async deleteOne() {\n    let filter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new delete_1.DeleteOneOperation(this, filter, (0, utils_1.resolveOptions)(this, options)));\n  }\n  /**\n   * Delete multiple documents from a collection\n   *\n   * @param filter - The filter used to select the documents to remove\n   * @param options - Optional settings for the command\n   */\n  async deleteMany() {\n    let filter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new delete_1.DeleteManyOperation(this, filter, (0, utils_1.resolveOptions)(this, options)));\n  }\n  /**\n   * Rename the collection.\n   *\n   * @remarks\n   * This operation does not inherit options from the Db or MongoClient.\n   *\n   * @param newName - New name of of the collection.\n   * @param options - Optional settings for the command\n   */\n  async rename(newName, options) {\n    // Intentionally, we do not inherit options from parent for this operation.\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new rename_1.RenameOperation(this, newName, {\n      ...options,\n      readPreference: read_preference_1.ReadPreference.PRIMARY\n    }));\n  }\n  /**\n   * Drop the collection from the database, removing it permanently. New accesses will create a new collection.\n   *\n   * @param options - Optional settings for the command\n   */\n  async drop(options) {\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new drop_1.DropCollectionOperation(this.s.db, this.collectionName, options));\n  }\n  async findOne() {\n    let filter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.find(filter, options).limit(-1).batchSize(1).next();\n  }\n  find() {\n    let filter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return new find_cursor_1.FindCursor(this.s.db.s.client, this.s.namespace, filter, (0, utils_1.resolveOptions)(this, options));\n  }\n  /**\n   * Returns the options of the collection.\n   *\n   * @param options - Optional settings for the command\n   */\n  async options(options) {\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new options_operation_1.OptionsOperation(this, (0, utils_1.resolveOptions)(this, options)));\n  }\n  /**\n   * Returns if the collection is a capped collection\n   *\n   * @param options - Optional settings for the command\n   */\n  async isCapped(options) {\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new is_capped_1.IsCappedOperation(this, (0, utils_1.resolveOptions)(this, options)));\n  }\n  /**\n   * Creates an index on the db and collection collection.\n   *\n   * @param indexSpec - The field name or index specification to create an index for\n   * @param options - Optional settings for the command\n   *\n   * @example\n   * ```ts\n   * const collection = client.db('foo').collection('bar');\n   *\n   * await collection.createIndex({ a: 1, b: -1 });\n   *\n   * // Alternate syntax for { c: 1, d: -1 } that ensures order of indexes\n   * await collection.createIndex([ [c, 1], [d, -1] ]);\n   *\n   * // Equivalent to { e: 1 }\n   * await collection.createIndex('e');\n   *\n   * // Equivalent to { f: 1, g: 1 }\n   * await collection.createIndex(['f', 'g'])\n   *\n   * // Equivalent to { h: 1, i: -1 }\n   * await collection.createIndex([ { h: 1 }, { i: -1 } ]);\n   *\n   * // Equivalent to { j: 1, k: -1, l: 2d }\n   * await collection.createIndex(['j', ['k', -1], { l: '2d' }])\n   * ```\n   */\n  async createIndex(indexSpec, options) {\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.CreateIndexOperation(this, this.collectionName, indexSpec, (0, utils_1.resolveOptions)(this, options)));\n  }\n  /**\n   * Creates multiple indexes in the collection, this method is only supported for\n   * MongoDB 2.6 or higher. Earlier version of MongoDB will throw a command not supported\n   * error.\n   *\n   * **Note**: Unlike {@link Collection#createIndex| createIndex}, this function takes in raw index specifications.\n   * Index specifications are defined {@link http://docs.mongodb.org/manual/reference/command/createIndexes/| here}.\n   *\n   * @param indexSpecs - An array of index specifications to be created\n   * @param options - Optional settings for the command\n   *\n   * @example\n   * ```ts\n   * const collection = client.db('foo').collection('bar');\n   * await collection.createIndexes([\n   *   // Simple index on field fizz\n   *   {\n   *     key: { fizz: 1 },\n   *   }\n   *   // wildcard index\n   *   {\n   *     key: { '$**': 1 }\n   *   },\n   *   // named index on darmok and jalad\n   *   {\n   *     key: { darmok: 1, jalad: -1 }\n   *     name: 'tanagra'\n   *   }\n   * ]);\n   * ```\n   */\n  async createIndexes(indexSpecs, options) {\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.CreateIndexesOperation(this, this.collectionName, indexSpecs, (0, utils_1.resolveOptions)(this, {\n      ...options,\n      maxTimeMS: undefined\n    })));\n  }\n  /**\n   * Drops an index from this collection.\n   *\n   * @param indexName - Name of the index to drop.\n   * @param options - Optional settings for the command\n   */\n  async dropIndex(indexName, options) {\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.DropIndexOperation(this, indexName, {\n      ...(0, utils_1.resolveOptions)(this, options),\n      readPreference: read_preference_1.ReadPreference.primary\n    }));\n  }\n  /**\n   * Drops all indexes from this collection.\n   *\n   * @param options - Optional settings for the command\n   */\n  async dropIndexes(options) {\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.DropIndexesOperation(this, (0, utils_1.resolveOptions)(this, options)));\n  }\n  /**\n   * Get the list of all indexes information for the collection.\n   *\n   * @param options - Optional settings for the command\n   */\n  listIndexes(options) {\n    return new list_indexes_cursor_1.ListIndexesCursor(this, (0, utils_1.resolveOptions)(this, options));\n  }\n  /**\n   * Checks if one or more indexes exist on the collection, fails on first non-existing index\n   *\n   * @param indexes - One or more index names to check.\n   * @param options - Optional settings for the command\n   */\n  async indexExists(indexes, options) {\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.IndexExistsOperation(this, indexes, (0, utils_1.resolveOptions)(this, options)));\n  }\n  /**\n   * Retrieves this collections index info.\n   *\n   * @param options - Optional settings for the command\n   */\n  async indexInformation(options) {\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.IndexInformationOperation(this.s.db, this.collectionName, (0, utils_1.resolveOptions)(this, options)));\n  }\n  /**\n   * Gets an estimate of the count of documents in a collection using collection metadata.\n   * This will always run a count command on all server versions.\n   *\n   * due to an oversight in versions 5.0.0-5.0.8 of MongoDB, the count command,\n   * which estimatedDocumentCount uses in its implementation, was not included in v1 of\n   * the Stable API, and so users of the Stable API with estimatedDocumentCount are\n   * recommended to upgrade their server version to 5.0.9+ or set apiStrict: false to avoid\n   * encountering errors.\n   *\n   * @see {@link https://www.mongodb.com/docs/manual/reference/command/count/#behavior|Count: Behavior}\n   * @param options - Optional settings for the command\n   */\n  async estimatedDocumentCount(options) {\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new estimated_document_count_1.EstimatedDocumentCountOperation(this, (0, utils_1.resolveOptions)(this, options)));\n  }\n  /**\n   * Gets the number of documents matching the filter.\n   * For a fast count of the total documents in a collection see {@link Collection#estimatedDocumentCount| estimatedDocumentCount}.\n   * **Note**: When migrating from {@link Collection#count| count} to {@link Collection#countDocuments| countDocuments}\n   * the following query operators must be replaced:\n   *\n   * | Operator | Replacement |\n   * | -------- | ----------- |\n   * | `$where`   | [`$expr`][1] |\n   * | `$near`    | [`$geoWithin`][2] with [`$center`][3] |\n   * | `$nearSphere` | [`$geoWithin`][2] with [`$centerSphere`][4] |\n   *\n   * [1]: https://docs.mongodb.com/manual/reference/operator/query/expr/\n   * [2]: https://docs.mongodb.com/manual/reference/operator/query/geoWithin/\n   * [3]: https://docs.mongodb.com/manual/reference/operator/query/center/#op._S_center\n   * [4]: https://docs.mongodb.com/manual/reference/operator/query/centerSphere/#op._S_centerSphere\n   *\n   * @param filter - The filter for the count\n   * @param options - Optional settings for the command\n   *\n   * @see https://docs.mongodb.com/manual/reference/operator/query/expr/\n   * @see https://docs.mongodb.com/manual/reference/operator/query/geoWithin/\n   * @see https://docs.mongodb.com/manual/reference/operator/query/center/#op._S_center\n   * @see https://docs.mongodb.com/manual/reference/operator/query/centerSphere/#op._S_centerSphere\n   */\n  async countDocuments() {\n    let filter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new count_documents_1.CountDocumentsOperation(this, filter, (0, utils_1.resolveOptions)(this, options)));\n  }\n  async distinct(key) {\n    let filter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new distinct_1.DistinctOperation(this, key, filter, (0, utils_1.resolveOptions)(this, options)));\n  }\n  /**\n   * Retrieve all the indexes on the collection.\n   *\n   * @param options - Optional settings for the command\n   */\n  async indexes(options) {\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.IndexesOperation(this, (0, utils_1.resolveOptions)(this, options)));\n  }\n  /**\n   * Get all the collection statistics.\n   *\n   * @param options - Optional settings for the command\n   */\n  async stats(options) {\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new stats_1.CollStatsOperation(this, options));\n  }\n  /**\n   * Find a document and delete it in one atomic operation. Requires a write lock for the duration of the operation.\n   *\n   * @param filter - The filter used to select the document to remove\n   * @param options - Optional settings for the command\n   */\n  async findOneAndDelete(filter, options) {\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new find_and_modify_1.FindOneAndDeleteOperation(this, filter, (0, utils_1.resolveOptions)(this, options)));\n  }\n  /**\n   * Find a document and replace it in one atomic operation. Requires a write lock for the duration of the operation.\n   *\n   * @param filter - The filter used to select the document to replace\n   * @param replacement - The Document that replaces the matching document\n   * @param options - Optional settings for the command\n   */\n  async findOneAndReplace(filter, replacement, options) {\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new find_and_modify_1.FindOneAndReplaceOperation(this, filter, replacement, (0, utils_1.resolveOptions)(this, options)));\n  }\n  /**\n   * Find a document and update it in one atomic operation. Requires a write lock for the duration of the operation.\n   *\n   * @param filter - The filter used to select the document to update\n   * @param update - Update operations to be performed on the document\n   * @param options - Optional settings for the command\n   */\n  async findOneAndUpdate(filter, update, options) {\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new find_and_modify_1.FindOneAndUpdateOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options)));\n  }\n  /**\n   * Execute an aggregation framework pipeline against the collection, needs MongoDB \\>= 2.2\n   *\n   * @param pipeline - An array of aggregation pipelines to execute\n   * @param options - Optional settings for the command\n   */\n  aggregate() {\n    let pipeline = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let options = arguments.length > 1 ? arguments[1] : undefined;\n    if (!Array.isArray(pipeline)) {\n      throw new error_1.MongoInvalidArgumentError('Argument \"pipeline\" must be an array of aggregation stages');\n    }\n    return new aggregation_cursor_1.AggregationCursor(this.s.db.s.client, this.s.namespace, pipeline, (0, utils_1.resolveOptions)(this, options));\n  }\n  /**\n   * Create a new Change Stream, watching for new changes (insertions, updates, replacements, deletions, and invalidations) in this collection.\n   *\n   * @remarks\n   * watch() accepts two generic arguments for distinct use cases:\n   * - The first is to override the schema that may be defined for this specific collection\n   * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument\n   * @example\n   * By just providing the first argument I can type the change to be `ChangeStreamDocument<{ _id: number }>`\n   * ```ts\n   * collection.watch<{ _id: number }>()\n   *   .on('change', change => console.log(change._id.toFixed(4)));\n   * ```\n   *\n   * @example\n   * Passing a second argument provides a way to reflect the type changes caused by an advanced pipeline.\n   * Here, we are using a pipeline to have MongoDB filter for insert changes only and add a comment.\n   * No need start from scratch on the ChangeStreamInsertDocument type!\n   * By using an intersection we can save time and ensure defaults remain the same type!\n   * ```ts\n   * collection\n   *   .watch<Schema, ChangeStreamInsertDocument<Schema> & { comment: string }>([\n   *     { $addFields: { comment: 'big changes' } },\n   *     { $match: { operationType: 'insert' } }\n   *   ])\n   *   .on('change', change => {\n   *     change.comment.startsWith('big');\n   *     change.operationType === 'insert';\n   *     // No need to narrow in code because the generics did that for us!\n   *     expectType<Schema>(change.fullDocument);\n   *   });\n   * ```\n   *\n   * @param pipeline - An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.\n   * @param options - Optional settings for the command\n   * @typeParam TLocal - Type of the data being detected by the change stream\n   * @typeParam TChange - Type of the whole change stream document emitted\n   */\n  watch() {\n    let pipeline = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // Allow optionally not specifying a pipeline\n    if (!Array.isArray(pipeline)) {\n      options = pipeline;\n      pipeline = [];\n    }\n    return new change_stream_1.ChangeStream(this, pipeline, (0, utils_1.resolveOptions)(this, options));\n  }\n  /**\n   * Initiate an Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.\n   *\n   * @throws MongoNotConnectedError\n   * @remarks\n   * **NOTE:** MongoClient must be connected prior to calling this method due to a known limitation in this legacy implementation.\n   * However, `collection.bulkWrite()` provides an equivalent API that does not require prior connecting.\n   */\n  initializeUnorderedBulkOp(options) {\n    return new unordered_1.UnorderedBulkOperation(this, (0, utils_1.resolveOptions)(this, options));\n  }\n  /**\n   * Initiate an In order bulk write operation. Operations will be serially executed in the order they are added, creating a new operation for each switch in types.\n   *\n   * @throws MongoNotConnectedError\n   * @remarks\n   * **NOTE:** MongoClient must be connected prior to calling this method due to a known limitation in this legacy implementation.\n   * However, `collection.bulkWrite()` provides an equivalent API that does not require prior connecting.\n   */\n  initializeOrderedBulkOp(options) {\n    return new ordered_1.OrderedBulkOperation(this, (0, utils_1.resolveOptions)(this, options));\n  }\n  /**\n   * An estimated count of matching documents in the db to a filter.\n   *\n   * **NOTE:** This method has been deprecated, since it does not provide an accurate count of the documents\n   * in a collection. To obtain an accurate count of documents in the collection, use {@link Collection#countDocuments| countDocuments}.\n   * To obtain an estimated count of all documents in the collection, use {@link Collection#estimatedDocumentCount| estimatedDocumentCount}.\n   *\n   * @deprecated use {@link Collection#countDocuments| countDocuments} or {@link Collection#estimatedDocumentCount| estimatedDocumentCount} instead\n   *\n   * @param filter - The filter for the count.\n   * @param options - Optional settings for the command\n   */\n  async count() {\n    let filter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new count_1.CountOperation(utils_1.MongoDBNamespace.fromString(this.namespace), filter, (0, utils_1.resolveOptions)(this, options)));\n  }\n}\nexports.Collection = Collection;","map":{"version":3,"mappings":"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","names":["Collection","constructor","db","name","options","s","namespace","utils_1","databaseName","pkFactory","readPreference","read_preference_1","fromOptions","bsonOptions","readConcern","read_concern_1","writeConcern","write_concern_1","dbName","collectionName","collection","toString","hint","collectionHint","v","insertOne","doc","client","insert_1","insertMany","docs","ordered","bulkWrite","operations","Array","isArray","error_1","bulk_write_1","updateOne","filter","update","update_1","replaceOne","replacement","updateMany","deleteOne","delete_1","deleteMany","rename","newName","rename_1","PRIMARY","drop","drop_1","findOne","find","limit","batchSize","next","find_cursor_1","options_operation_1","isCapped","is_capped_1","createIndex","indexSpec","indexes_1","createIndexes","indexSpecs","maxTimeMS","undefined","dropIndex","indexName","primary","dropIndexes","listIndexes","list_indexes_cursor_1","indexExists","indexes","indexInformation","estimatedDocumentCount","estimated_document_count_1","countDocuments","count_documents_1","distinct","key","distinct_1","stats","stats_1","findOneAndDelete","find_and_modify_1","findOneAndReplace","findOneAndUpdate","aggregate","pipeline","aggregation_cursor_1","watch","change_stream_1","initializeUnorderedBulkOp","unordered_1","initializeOrderedBulkOp","ordered_1","count","count_1","fromString","exports"],"sources":["/Users/alvarodgzz/Documents/calendarioAnae/app-calendario/node_modules/mongodb/src/collection.ts"],"sourcesContent":["import { BSONSerializeOptions, Document, resolveBSONOptions } from './bson';\nimport type { AnyBulkWriteOperation, BulkWriteOptions, BulkWriteResult } from './bulk/common';\nimport { OrderedBulkOperation } from './bulk/ordered';\nimport { UnorderedBulkOperation } from './bulk/unordered';\nimport { ChangeStream, ChangeStreamDocument, ChangeStreamOptions } from './change_stream';\nimport { AggregationCursor } from './cursor/aggregation_cursor';\nimport { FindCursor } from './cursor/find_cursor';\nimport { ListIndexesCursor } from './cursor/list_indexes_cursor';\nimport type { Db } from './db';\nimport { MongoInvalidArgumentError } from './error';\nimport type { PkFactory } from './mongo_client';\nimport type {\n  Filter,\n  Flatten,\n  OptionalUnlessRequiredId,\n  TODO_NODE_3286,\n  UpdateFilter,\n  WithId,\n  WithoutId\n} from './mongo_types';\nimport type { AggregateOptions } from './operations/aggregate';\nimport { BulkWriteOperation } from './operations/bulk_write';\nimport type { IndexInformationOptions } from './operations/common_functions';\nimport { CountOperation, CountOptions } from './operations/count';\nimport { CountDocumentsOperation, CountDocumentsOptions } from './operations/count_documents';\nimport {\n  DeleteManyOperation,\n  DeleteOneOperation,\n  DeleteOptions,\n  DeleteResult\n} from './operations/delete';\nimport { DistinctOperation, DistinctOptions } from './operations/distinct';\nimport { DropCollectionOperation, DropCollectionOptions } from './operations/drop';\nimport {\n  EstimatedDocumentCountOperation,\n  EstimatedDocumentCountOptions\n} from './operations/estimated_document_count';\nimport { executeOperation } from './operations/execute_operation';\nimport type { FindOptions } from './operations/find';\nimport {\n  FindOneAndDeleteOperation,\n  FindOneAndDeleteOptions,\n  FindOneAndReplaceOperation,\n  FindOneAndReplaceOptions,\n  FindOneAndUpdateOperation,\n  FindOneAndUpdateOptions\n} from './operations/find_and_modify';\nimport {\n  CreateIndexesOperation,\n  CreateIndexesOptions,\n  CreateIndexOperation,\n  DropIndexesOperation,\n  DropIndexesOptions,\n  DropIndexOperation,\n  IndexDescription,\n  IndexesOperation,\n  IndexExistsOperation,\n  IndexInformationOperation,\n  IndexSpecification,\n  ListIndexesOptions\n} from './operations/indexes';\nimport {\n  InsertManyOperation,\n  InsertManyResult,\n  InsertOneOperation,\n  InsertOneOptions,\n  InsertOneResult\n} from './operations/insert';\nimport { IsCappedOperation } from './operations/is_capped';\nimport type { Hint, OperationOptions } from './operations/operation';\nimport { OptionsOperation } from './operations/options_operation';\nimport { RenameOperation, RenameOptions } from './operations/rename';\nimport { CollStats, CollStatsOperation, CollStatsOptions } from './operations/stats';\nimport {\n  ReplaceOneOperation,\n  ReplaceOptions,\n  UpdateManyOperation,\n  UpdateOneOperation,\n  UpdateOptions,\n  UpdateResult\n} from './operations/update';\nimport { ReadConcern, ReadConcernLike } from './read_concern';\nimport { ReadPreference, ReadPreferenceLike } from './read_preference';\nimport {\n  checkCollectionName,\n  DEFAULT_PK_FACTORY,\n  MongoDBNamespace,\n  normalizeHintField,\n  resolveOptions\n} from './utils';\nimport { WriteConcern, WriteConcernOptions } from './write_concern';\n\n/**\n * @public\n * @deprecated This type will be completely removed in 5.0 and findOneAndUpdate,\n *             findOneAndDelete, and findOneAndReplace will then return the\n *             actual result document.\n */\nexport interface ModifyResult<TSchema = Document> {\n  value: WithId<TSchema> | null;\n  lastErrorObject?: Document;\n  ok: 0 | 1;\n}\n\n/** @public */\nexport interface CollectionOptions extends BSONSerializeOptions, WriteConcernOptions {\n  /** Specify a read concern for the collection. (only MongoDB 3.2 or higher supported) */\n  readConcern?: ReadConcernLike;\n  /** The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST). */\n  readPreference?: ReadPreferenceLike;\n}\n\n/** @internal */\nexport interface CollectionPrivate {\n  pkFactory: PkFactory;\n  db: Db;\n  options: any;\n  namespace: MongoDBNamespace;\n  readPreference?: ReadPreference;\n  bsonOptions: BSONSerializeOptions;\n  collectionHint?: Hint;\n  readConcern?: ReadConcern;\n  writeConcern?: WriteConcern;\n}\n\n/**\n * The **Collection** class is an internal class that embodies a MongoDB collection\n * allowing for insert/find/update/delete and other command operation on that MongoDB collection.\n *\n * **COLLECTION Cannot directly be instantiated**\n * @public\n *\n * @example\n * ```ts\n * import { MongoClient } from 'mongodb';\n *\n * interface Pet {\n *   name: string;\n *   kind: 'dog' | 'cat' | 'fish';\n * }\n *\n * const client = new MongoClient('mongodb://localhost:27017');\n * const pets = client.db().collection<Pet>('pets');\n *\n * const petCursor = pets.find();\n *\n * for await (const pet of petCursor) {\n *   console.log(`${pet.name} is a ${pet.kind}!`);\n * }\n * ```\n */\nexport class Collection<TSchema extends Document = Document> {\n  /** @internal */\n  s: CollectionPrivate;\n\n  /**\n   * Create a new Collection instance\n   * @internal\n   */\n  constructor(db: Db, name: string, options?: CollectionOptions) {\n    checkCollectionName(name);\n\n    // Internal state\n    this.s = {\n      db,\n      options,\n      namespace: new MongoDBNamespace(db.databaseName, name),\n      pkFactory: db.options?.pkFactory ?? DEFAULT_PK_FACTORY,\n      readPreference: ReadPreference.fromOptions(options),\n      bsonOptions: resolveBSONOptions(options, db),\n      readConcern: ReadConcern.fromOptions(options),\n      writeConcern: WriteConcern.fromOptions(options)\n    };\n  }\n\n  /**\n   * The name of the database this collection belongs to\n   */\n  get dbName(): string {\n    return this.s.namespace.db;\n  }\n\n  /**\n   * The name of this collection\n   */\n  get collectionName(): string {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.s.namespace.collection!;\n  }\n\n  /**\n   * The namespace of this collection, in the format `${this.dbName}.${this.collectionName}`\n   */\n  get namespace(): string {\n    return this.s.namespace.toString();\n  }\n\n  /**\n   * The current readConcern of the collection. If not explicitly defined for\n   * this collection, will be inherited from the parent DB\n   */\n  get readConcern(): ReadConcern | undefined {\n    if (this.s.readConcern == null) {\n      return this.s.db.readConcern;\n    }\n    return this.s.readConcern;\n  }\n\n  /**\n   * The current readPreference of the collection. If not explicitly defined for\n   * this collection, will be inherited from the parent DB\n   */\n  get readPreference(): ReadPreference | undefined {\n    if (this.s.readPreference == null) {\n      return this.s.db.readPreference;\n    }\n\n    return this.s.readPreference;\n  }\n\n  get bsonOptions(): BSONSerializeOptions {\n    return this.s.bsonOptions;\n  }\n\n  /**\n   * The current writeConcern of the collection. If not explicitly defined for\n   * this collection, will be inherited from the parent DB\n   */\n  get writeConcern(): WriteConcern | undefined {\n    if (this.s.writeConcern == null) {\n      return this.s.db.writeConcern;\n    }\n    return this.s.writeConcern;\n  }\n\n  /** The current index hint for the collection */\n  get hint(): Hint | undefined {\n    return this.s.collectionHint;\n  }\n\n  set hint(v: Hint | undefined) {\n    this.s.collectionHint = normalizeHintField(v);\n  }\n\n  /**\n   * Inserts a single document into MongoDB. If documents passed in do not contain the **_id** field,\n   * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n   * can be overridden by setting the **forceServerObjectId** flag.\n   *\n   * @param doc - The document to insert\n   * @param options - Optional settings for the command\n   */\n  async insertOne(\n    doc: OptionalUnlessRequiredId<TSchema>,\n    options?: InsertOneOptions\n  ): Promise<InsertOneResult<TSchema>> {\n    return executeOperation(\n      this.s.db.s.client,\n      new InsertOneOperation(\n        this as TODO_NODE_3286,\n        doc,\n        resolveOptions(this, options)\n      ) as TODO_NODE_3286\n    );\n  }\n\n  /**\n   * Inserts an array of documents into MongoDB. If documents passed in do not contain the **_id** field,\n   * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n   * can be overridden by setting the **forceServerObjectId** flag.\n   *\n   * @param docs - The documents to insert\n   * @param options - Optional settings for the command\n   */\n  async insertMany(\n    docs: OptionalUnlessRequiredId<TSchema>[],\n    options?: BulkWriteOptions\n  ): Promise<InsertManyResult<TSchema>> {\n    return executeOperation(\n      this.s.db.s.client,\n      new InsertManyOperation(\n        this as TODO_NODE_3286,\n        docs,\n        resolveOptions(this, options ?? { ordered: true })\n      ) as TODO_NODE_3286\n    );\n  }\n\n  /**\n   * Perform a bulkWrite operation without a fluent API\n   *\n   * Legal operation types are\n   * - `insertOne`\n   * - `replaceOne`\n   * - `updateOne`\n   * - `updateMany`\n   * - `deleteOne`\n   * - `deleteMany`\n   *\n   * If documents passed in do not contain the **_id** field,\n   * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n   * can be overridden by setting the **forceServerObjectId** flag.\n   *\n   * @param operations - Bulk operations to perform\n   * @param options - Optional settings for the command\n   * @throws MongoDriverError if operations is not an array\n   */\n  async bulkWrite(\n    operations: AnyBulkWriteOperation<TSchema>[],\n    options?: BulkWriteOptions\n  ): Promise<BulkWriteResult> {\n    if (!Array.isArray(operations)) {\n      throw new MongoInvalidArgumentError('Argument \"operations\" must be an array of documents');\n    }\n\n    return executeOperation(\n      this.s.db.s.client,\n      new BulkWriteOperation(\n        this as TODO_NODE_3286,\n        operations as TODO_NODE_3286,\n        resolveOptions(this, options ?? { ordered: true })\n      )\n    );\n  }\n\n  /**\n   * Update a single document in a collection\n   *\n   * @param filter - The filter used to select the document to update\n   * @param update - The update operations to be applied to the document\n   * @param options - Optional settings for the command\n   */\n  async updateOne(\n    filter: Filter<TSchema>,\n    update: UpdateFilter<TSchema> | Partial<TSchema>,\n    options?: UpdateOptions\n  ): Promise<UpdateResult> {\n    return executeOperation(\n      this.s.db.s.client,\n      new UpdateOneOperation(\n        this as TODO_NODE_3286,\n        filter,\n        update,\n        resolveOptions(this, options)\n      ) as TODO_NODE_3286\n    );\n  }\n\n  /**\n   * Replace a document in a collection with another document\n   *\n   * @param filter - The filter used to select the document to replace\n   * @param replacement - The Document that replaces the matching document\n   * @param options - Optional settings for the command\n   */\n  async replaceOne(\n    filter: Filter<TSchema>,\n    replacement: WithoutId<TSchema>,\n    options?: ReplaceOptions\n  ): Promise<UpdateResult | Document> {\n    return executeOperation(\n      this.s.db.s.client,\n      new ReplaceOneOperation(\n        this as TODO_NODE_3286,\n        filter,\n        replacement,\n        resolveOptions(this, options)\n      )\n    );\n  }\n\n  /**\n   * Update multiple documents in a collection\n   *\n   * @param filter - The filter used to select the documents to update\n   * @param update - The update operations to be applied to the documents\n   * @param options - Optional settings for the command\n   */\n  async updateMany(\n    filter: Filter<TSchema>,\n    update: UpdateFilter<TSchema>,\n    options?: UpdateOptions\n  ): Promise<UpdateResult> {\n    return executeOperation(\n      this.s.db.s.client,\n      new UpdateManyOperation(\n        this as TODO_NODE_3286,\n        filter,\n        update,\n        resolveOptions(this, options)\n      ) as TODO_NODE_3286\n    );\n  }\n\n  /**\n   * Delete a document from a collection\n   *\n   * @param filter - The filter used to select the document to remove\n   * @param options - Optional settings for the command\n   */\n  async deleteOne(\n    filter: Filter<TSchema> = {},\n    options: DeleteOptions = {}\n  ): Promise<DeleteResult> {\n    return executeOperation(\n      this.s.db.s.client,\n      new DeleteOneOperation(this as TODO_NODE_3286, filter, resolveOptions(this, options))\n    );\n  }\n\n  /**\n   * Delete multiple documents from a collection\n   *\n   * @param filter - The filter used to select the documents to remove\n   * @param options - Optional settings for the command\n   */\n  async deleteMany(\n    filter: Filter<TSchema> = {},\n    options: DeleteOptions = {}\n  ): Promise<DeleteResult> {\n    return executeOperation(\n      this.s.db.s.client,\n      new DeleteManyOperation(this as TODO_NODE_3286, filter, resolveOptions(this, options))\n    );\n  }\n\n  /**\n   * Rename the collection.\n   *\n   * @remarks\n   * This operation does not inherit options from the Db or MongoClient.\n   *\n   * @param newName - New name of of the collection.\n   * @param options - Optional settings for the command\n   */\n  async rename(newName: string, options?: RenameOptions): Promise<Collection> {\n    // Intentionally, we do not inherit options from parent for this operation.\n    return executeOperation(\n      this.s.db.s.client,\n      new RenameOperation(this as TODO_NODE_3286, newName, {\n        ...options,\n        readPreference: ReadPreference.PRIMARY\n      }) as TODO_NODE_3286\n    );\n  }\n\n  /**\n   * Drop the collection from the database, removing it permanently. New accesses will create a new collection.\n   *\n   * @param options - Optional settings for the command\n   */\n  async drop(options?: DropCollectionOptions): Promise<boolean> {\n    return executeOperation(\n      this.s.db.s.client,\n      new DropCollectionOperation(this.s.db, this.collectionName, options)\n    );\n  }\n\n  /**\n   * Fetches the first document that matches the filter\n   *\n   * @param filter - Query for find Operation\n   * @param options - Optional settings for the command\n   */\n  async findOne(): Promise<WithId<TSchema> | null>;\n  async findOne(filter: Filter<TSchema>): Promise<WithId<TSchema> | null>;\n  async findOne(filter: Filter<TSchema>, options: FindOptions): Promise<WithId<TSchema> | null>;\n\n  // allow an override of the schema.\n  async findOne<T = TSchema>(): Promise<T | null>;\n  async findOne<T = TSchema>(filter: Filter<TSchema>): Promise<T | null>;\n  async findOne<T = TSchema>(filter: Filter<TSchema>, options?: FindOptions): Promise<T | null>;\n\n  async findOne(\n    filter: Filter<TSchema> = {},\n    options: FindOptions = {}\n  ): Promise<WithId<TSchema> | null> {\n    return this.find(filter, options).limit(-1).batchSize(1).next();\n  }\n\n  /**\n   * Creates a cursor for a filter that can be used to iterate over results from MongoDB\n   *\n   * @param filter - The filter predicate. If unspecified, then all documents in the collection will match the predicate\n   */\n  find(): FindCursor<WithId<TSchema>>;\n  find(filter: Filter<TSchema>, options?: FindOptions): FindCursor<WithId<TSchema>>;\n  find<T extends Document>(filter: Filter<TSchema>, options?: FindOptions): FindCursor<T>;\n  find(filter: Filter<TSchema> = {}, options: FindOptions = {}): FindCursor<WithId<TSchema>> {\n    return new FindCursor<WithId<TSchema>>(\n      this.s.db.s.client,\n      this.s.namespace,\n      filter,\n      resolveOptions(this as TODO_NODE_3286, options)\n    );\n  }\n\n  /**\n   * Returns the options of the collection.\n   *\n   * @param options - Optional settings for the command\n   */\n  async options(options?: OperationOptions): Promise<Document> {\n    return executeOperation(\n      this.s.db.s.client,\n      new OptionsOperation(this as TODO_NODE_3286, resolveOptions(this, options))\n    );\n  }\n\n  /**\n   * Returns if the collection is a capped collection\n   *\n   * @param options - Optional settings for the command\n   */\n  async isCapped(options?: OperationOptions): Promise<boolean> {\n    return executeOperation(\n      this.s.db.s.client,\n      new IsCappedOperation(this as TODO_NODE_3286, resolveOptions(this, options))\n    );\n  }\n\n  /**\n   * Creates an index on the db and collection collection.\n   *\n   * @param indexSpec - The field name or index specification to create an index for\n   * @param options - Optional settings for the command\n   *\n   * @example\n   * ```ts\n   * const collection = client.db('foo').collection('bar');\n   *\n   * await collection.createIndex({ a: 1, b: -1 });\n   *\n   * // Alternate syntax for { c: 1, d: -1 } that ensures order of indexes\n   * await collection.createIndex([ [c, 1], [d, -1] ]);\n   *\n   * // Equivalent to { e: 1 }\n   * await collection.createIndex('e');\n   *\n   * // Equivalent to { f: 1, g: 1 }\n   * await collection.createIndex(['f', 'g'])\n   *\n   * // Equivalent to { h: 1, i: -1 }\n   * await collection.createIndex([ { h: 1 }, { i: -1 } ]);\n   *\n   * // Equivalent to { j: 1, k: -1, l: 2d }\n   * await collection.createIndex(['j', ['k', -1], { l: '2d' }])\n   * ```\n   */\n  async createIndex(\n    indexSpec: IndexSpecification,\n    options?: CreateIndexesOptions\n  ): Promise<string> {\n    return executeOperation(\n      this.s.db.s.client,\n      new CreateIndexOperation(\n        this as TODO_NODE_3286,\n        this.collectionName,\n        indexSpec,\n        resolveOptions(this, options)\n      )\n    );\n  }\n\n  /**\n   * Creates multiple indexes in the collection, this method is only supported for\n   * MongoDB 2.6 or higher. Earlier version of MongoDB will throw a command not supported\n   * error.\n   *\n   * **Note**: Unlike {@link Collection#createIndex| createIndex}, this function takes in raw index specifications.\n   * Index specifications are defined {@link http://docs.mongodb.org/manual/reference/command/createIndexes/| here}.\n   *\n   * @param indexSpecs - An array of index specifications to be created\n   * @param options - Optional settings for the command\n   *\n   * @example\n   * ```ts\n   * const collection = client.db('foo').collection('bar');\n   * await collection.createIndexes([\n   *   // Simple index on field fizz\n   *   {\n   *     key: { fizz: 1 },\n   *   }\n   *   // wildcard index\n   *   {\n   *     key: { '$**': 1 }\n   *   },\n   *   // named index on darmok and jalad\n   *   {\n   *     key: { darmok: 1, jalad: -1 }\n   *     name: 'tanagra'\n   *   }\n   * ]);\n   * ```\n   */\n  async createIndexes(\n    indexSpecs: IndexDescription[],\n    options?: CreateIndexesOptions\n  ): Promise<string[]> {\n    return executeOperation(\n      this.s.db.s.client,\n      new CreateIndexesOperation(\n        this as TODO_NODE_3286,\n        this.collectionName,\n        indexSpecs,\n        resolveOptions(this, { ...options, maxTimeMS: undefined })\n      )\n    );\n  }\n\n  /**\n   * Drops an index from this collection.\n   *\n   * @param indexName - Name of the index to drop.\n   * @param options - Optional settings for the command\n   */\n  async dropIndex(indexName: string, options?: DropIndexesOptions): Promise<Document> {\n    return executeOperation(\n      this.s.db.s.client,\n      new DropIndexOperation(this as TODO_NODE_3286, indexName, {\n        ...resolveOptions(this, options),\n        readPreference: ReadPreference.primary\n      })\n    );\n  }\n\n  /**\n   * Drops all indexes from this collection.\n   *\n   * @param options - Optional settings for the command\n   */\n  async dropIndexes(options?: DropIndexesOptions): Promise<Document> {\n    return executeOperation(\n      this.s.db.s.client,\n      new DropIndexesOperation(this as TODO_NODE_3286, resolveOptions(this, options))\n    );\n  }\n\n  /**\n   * Get the list of all indexes information for the collection.\n   *\n   * @param options - Optional settings for the command\n   */\n  listIndexes(options?: ListIndexesOptions): ListIndexesCursor {\n    return new ListIndexesCursor(this as TODO_NODE_3286, resolveOptions(this, options));\n  }\n\n  /**\n   * Checks if one or more indexes exist on the collection, fails on first non-existing index\n   *\n   * @param indexes - One or more index names to check.\n   * @param options - Optional settings for the command\n   */\n  async indexExists(\n    indexes: string | string[],\n    options?: IndexInformationOptions\n  ): Promise<boolean> {\n    return executeOperation(\n      this.s.db.s.client,\n      new IndexExistsOperation(this as TODO_NODE_3286, indexes, resolveOptions(this, options))\n    );\n  }\n\n  /**\n   * Retrieves this collections index info.\n   *\n   * @param options - Optional settings for the command\n   */\n  async indexInformation(options?: IndexInformationOptions): Promise<Document> {\n    return executeOperation(\n      this.s.db.s.client,\n      new IndexInformationOperation(this.s.db, this.collectionName, resolveOptions(this, options))\n    );\n  }\n\n  /**\n   * Gets an estimate of the count of documents in a collection using collection metadata.\n   * This will always run a count command on all server versions.\n   *\n   * due to an oversight in versions 5.0.0-5.0.8 of MongoDB, the count command,\n   * which estimatedDocumentCount uses in its implementation, was not included in v1 of\n   * the Stable API, and so users of the Stable API with estimatedDocumentCount are\n   * recommended to upgrade their server version to 5.0.9+ or set apiStrict: false to avoid\n   * encountering errors.\n   *\n   * @see {@link https://www.mongodb.com/docs/manual/reference/command/count/#behavior|Count: Behavior}\n   * @param options - Optional settings for the command\n   */\n  async estimatedDocumentCount(options?: EstimatedDocumentCountOptions): Promise<number> {\n    return executeOperation(\n      this.s.db.s.client,\n      new EstimatedDocumentCountOperation(this as TODO_NODE_3286, resolveOptions(this, options))\n    );\n  }\n\n  /**\n   * Gets the number of documents matching the filter.\n   * For a fast count of the total documents in a collection see {@link Collection#estimatedDocumentCount| estimatedDocumentCount}.\n   * **Note**: When migrating from {@link Collection#count| count} to {@link Collection#countDocuments| countDocuments}\n   * the following query operators must be replaced:\n   *\n   * | Operator | Replacement |\n   * | -------- | ----------- |\n   * | `$where`   | [`$expr`][1] |\n   * | `$near`    | [`$geoWithin`][2] with [`$center`][3] |\n   * | `$nearSphere` | [`$geoWithin`][2] with [`$centerSphere`][4] |\n   *\n   * [1]: https://docs.mongodb.com/manual/reference/operator/query/expr/\n   * [2]: https://docs.mongodb.com/manual/reference/operator/query/geoWithin/\n   * [3]: https://docs.mongodb.com/manual/reference/operator/query/center/#op._S_center\n   * [4]: https://docs.mongodb.com/manual/reference/operator/query/centerSphere/#op._S_centerSphere\n   *\n   * @param filter - The filter for the count\n   * @param options - Optional settings for the command\n   *\n   * @see https://docs.mongodb.com/manual/reference/operator/query/expr/\n   * @see https://docs.mongodb.com/manual/reference/operator/query/geoWithin/\n   * @see https://docs.mongodb.com/manual/reference/operator/query/center/#op._S_center\n   * @see https://docs.mongodb.com/manual/reference/operator/query/centerSphere/#op._S_centerSphere\n   */\n  async countDocuments(\n    filter: Document = {},\n    options: CountDocumentsOptions = {}\n  ): Promise<number> {\n    return executeOperation(\n      this.s.db.s.client,\n      new CountDocumentsOperation(this as TODO_NODE_3286, filter, resolveOptions(this, options))\n    );\n  }\n\n  /**\n   * The distinct command returns a list of distinct values for the given key across a collection.\n   *\n   * @param key - Field of the document to find distinct values for\n   * @param filter - The filter for filtering the set of documents to which we apply the distinct filter.\n   * @param options - Optional settings for the command\n   */\n  distinct<Key extends keyof WithId<TSchema>>(\n    key: Key\n  ): Promise<Array<Flatten<WithId<TSchema>[Key]>>>;\n  distinct<Key extends keyof WithId<TSchema>>(\n    key: Key,\n    filter: Filter<TSchema>\n  ): Promise<Array<Flatten<WithId<TSchema>[Key]>>>;\n  distinct<Key extends keyof WithId<TSchema>>(\n    key: Key,\n    filter: Filter<TSchema>,\n    options: DistinctOptions\n  ): Promise<Array<Flatten<WithId<TSchema>[Key]>>>;\n\n  // Embedded documents overload\n  distinct(key: string): Promise<any[]>;\n  distinct(key: string, filter: Filter<TSchema>): Promise<any[]>;\n  distinct(key: string, filter: Filter<TSchema>, options: DistinctOptions): Promise<any[]>;\n\n  async distinct<Key extends keyof WithId<TSchema>>(\n    key: Key,\n    filter: Filter<TSchema> = {},\n    options: DistinctOptions = {}\n  ): Promise<any[]> {\n    return executeOperation(\n      this.s.db.s.client,\n      new DistinctOperation(\n        this as TODO_NODE_3286,\n        key as TODO_NODE_3286,\n        filter,\n        resolveOptions(this, options)\n      )\n    );\n  }\n\n  /**\n   * Retrieve all the indexes on the collection.\n   *\n   * @param options - Optional settings for the command\n   */\n  async indexes(options?: IndexInformationOptions): Promise<Document[]> {\n    return executeOperation(\n      this.s.db.s.client,\n      new IndexesOperation(this as TODO_NODE_3286, resolveOptions(this, options))\n    );\n  }\n\n  /**\n   * Get all the collection statistics.\n   *\n   * @param options - Optional settings for the command\n   */\n  async stats(options?: CollStatsOptions): Promise<CollStats> {\n    return executeOperation(\n      this.s.db.s.client,\n      new CollStatsOperation(this as TODO_NODE_3286, options) as TODO_NODE_3286\n    );\n  }\n\n  /**\n   * Find a document and delete it in one atomic operation. Requires a write lock for the duration of the operation.\n   *\n   * @param filter - The filter used to select the document to remove\n   * @param options - Optional settings for the command\n   */\n  async findOneAndDelete(\n    filter: Filter<TSchema>,\n    options?: FindOneAndDeleteOptions\n  ): Promise<ModifyResult<TSchema>> {\n    return executeOperation(\n      this.s.db.s.client,\n      new FindOneAndDeleteOperation(\n        this as TODO_NODE_3286,\n        filter,\n        resolveOptions(this, options)\n      ) as TODO_NODE_3286\n    );\n  }\n\n  /**\n   * Find a document and replace it in one atomic operation. Requires a write lock for the duration of the operation.\n   *\n   * @param filter - The filter used to select the document to replace\n   * @param replacement - The Document that replaces the matching document\n   * @param options - Optional settings for the command\n   */\n  async findOneAndReplace(\n    filter: Filter<TSchema>,\n    replacement: WithoutId<TSchema>,\n    options?: FindOneAndReplaceOptions\n  ): Promise<ModifyResult<TSchema>> {\n    return executeOperation(\n      this.s.db.s.client,\n      new FindOneAndReplaceOperation(\n        this as TODO_NODE_3286,\n        filter,\n        replacement,\n        resolveOptions(this, options)\n      ) as TODO_NODE_3286\n    );\n  }\n\n  /**\n   * Find a document and update it in one atomic operation. Requires a write lock for the duration of the operation.\n   *\n   * @param filter - The filter used to select the document to update\n   * @param update - Update operations to be performed on the document\n   * @param options - Optional settings for the command\n   */\n  async findOneAndUpdate(\n    filter: Filter<TSchema>,\n    update: UpdateFilter<TSchema>,\n    options?: FindOneAndUpdateOptions\n  ): Promise<ModifyResult<TSchema>> {\n    return executeOperation(\n      this.s.db.s.client,\n      new FindOneAndUpdateOperation(\n        this as TODO_NODE_3286,\n        filter,\n        update,\n        resolveOptions(this, options)\n      ) as TODO_NODE_3286\n    );\n  }\n\n  /**\n   * Execute an aggregation framework pipeline against the collection, needs MongoDB \\>= 2.2\n   *\n   * @param pipeline - An array of aggregation pipelines to execute\n   * @param options - Optional settings for the command\n   */\n  aggregate<T extends Document = Document>(\n    pipeline: Document[] = [],\n    options?: AggregateOptions\n  ): AggregationCursor<T> {\n    if (!Array.isArray(pipeline)) {\n      throw new MongoInvalidArgumentError(\n        'Argument \"pipeline\" must be an array of aggregation stages'\n      );\n    }\n\n    return new AggregationCursor(\n      this.s.db.s.client,\n      this.s.namespace,\n      pipeline,\n      resolveOptions(this, options)\n    );\n  }\n\n  /**\n   * Create a new Change Stream, watching for new changes (insertions, updates, replacements, deletions, and invalidations) in this collection.\n   *\n   * @remarks\n   * watch() accepts two generic arguments for distinct use cases:\n   * - The first is to override the schema that may be defined for this specific collection\n   * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument\n   * @example\n   * By just providing the first argument I can type the change to be `ChangeStreamDocument<{ _id: number }>`\n   * ```ts\n   * collection.watch<{ _id: number }>()\n   *   .on('change', change => console.log(change._id.toFixed(4)));\n   * ```\n   *\n   * @example\n   * Passing a second argument provides a way to reflect the type changes caused by an advanced pipeline.\n   * Here, we are using a pipeline to have MongoDB filter for insert changes only and add a comment.\n   * No need start from scratch on the ChangeStreamInsertDocument type!\n   * By using an intersection we can save time and ensure defaults remain the same type!\n   * ```ts\n   * collection\n   *   .watch<Schema, ChangeStreamInsertDocument<Schema> & { comment: string }>([\n   *     { $addFields: { comment: 'big changes' } },\n   *     { $match: { operationType: 'insert' } }\n   *   ])\n   *   .on('change', change => {\n   *     change.comment.startsWith('big');\n   *     change.operationType === 'insert';\n   *     // No need to narrow in code because the generics did that for us!\n   *     expectType<Schema>(change.fullDocument);\n   *   });\n   * ```\n   *\n   * @param pipeline - An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.\n   * @param options - Optional settings for the command\n   * @typeParam TLocal - Type of the data being detected by the change stream\n   * @typeParam TChange - Type of the whole change stream document emitted\n   */\n  watch<TLocal extends Document = TSchema, TChange extends Document = ChangeStreamDocument<TLocal>>(\n    pipeline: Document[] = [],\n    options: ChangeStreamOptions = {}\n  ): ChangeStream<TLocal, TChange> {\n    // Allow optionally not specifying a pipeline\n    if (!Array.isArray(pipeline)) {\n      options = pipeline;\n      pipeline = [];\n    }\n\n    return new ChangeStream<TLocal, TChange>(this, pipeline, resolveOptions(this, options));\n  }\n\n  /**\n   * Initiate an Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.\n   *\n   * @throws MongoNotConnectedError\n   * @remarks\n   * **NOTE:** MongoClient must be connected prior to calling this method due to a known limitation in this legacy implementation.\n   * However, `collection.bulkWrite()` provides an equivalent API that does not require prior connecting.\n   */\n  initializeUnorderedBulkOp(options?: BulkWriteOptions): UnorderedBulkOperation {\n    return new UnorderedBulkOperation(this as TODO_NODE_3286, resolveOptions(this, options));\n  }\n\n  /**\n   * Initiate an In order bulk write operation. Operations will be serially executed in the order they are added, creating a new operation for each switch in types.\n   *\n   * @throws MongoNotConnectedError\n   * @remarks\n   * **NOTE:** MongoClient must be connected prior to calling this method due to a known limitation in this legacy implementation.\n   * However, `collection.bulkWrite()` provides an equivalent API that does not require prior connecting.\n   */\n  initializeOrderedBulkOp(options?: BulkWriteOptions): OrderedBulkOperation {\n    return new OrderedBulkOperation(this as TODO_NODE_3286, resolveOptions(this, options));\n  }\n\n  /**\n   * An estimated count of matching documents in the db to a filter.\n   *\n   * **NOTE:** This method has been deprecated, since it does not provide an accurate count of the documents\n   * in a collection. To obtain an accurate count of documents in the collection, use {@link Collection#countDocuments| countDocuments}.\n   * To obtain an estimated count of all documents in the collection, use {@link Collection#estimatedDocumentCount| estimatedDocumentCount}.\n   *\n   * @deprecated use {@link Collection#countDocuments| countDocuments} or {@link Collection#estimatedDocumentCount| estimatedDocumentCount} instead\n   *\n   * @param filter - The filter for the count.\n   * @param options - Optional settings for the command\n   */\n  async count(filter: Filter<TSchema> = {}, options: CountOptions = {}): Promise<number> {\n    return executeOperation(\n      this.s.db.s.client,\n      new CountOperation(\n        MongoDBNamespace.fromString(this.namespace),\n        filter,\n        resolveOptions(this, options)\n      )\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}